# 1.3 네트워크 코어

1.2절의 종단 시스템을 연결하는 패킷 스위치와 링크의 그물망(mesh)에 대하여 살펴보도록 하자.

아래 그림에서의 굵은 선들은 네트워크 코어를 나타낸 것이다.

<p align="center"><img width="450" alt="네트워크 코어" src="https://user-images.githubusercontent.com/86337233/210137238-bf8d10d3-ef09-4263-9339-7fedbb2d619e.png">

<br/>
<br/>

**링크와 스위치의 네트워크를 통해 데이터를 이동시키는** 두 가지 기본 방식

1. `패킷 교환(packet switching)` : 보장되지 않는 (e.g., 인터넷)
2. `회선 교환(circuit switching)` : 자원을 예약 → 보장된

<br/>
<br/>
<br/>

# 1.3.1 패킷 교환(packet switching)

종단 시스템들은 서로 `메시지(message)`를 교환한다. (**출발지 종단 시스템에서 목적지 종단 시스템으로** 메시지를 보냄)

<br/>

1. 송신 시스템은 메시지를 `패킷(packet)`이라고 하는 작은 데이터 덩어리로 분할한다.


2. 각 패킷은 `통신 링크(communication link)`와 `패킷 스위치(packet switch)`를 거치게 된다.
    - 패킷 스위치에는 <b>라우터(router)</b>와 <b>링크 계층 스위치(link-layer switch)</b>의 두 가지 유형이 존재한다.


3. 패킷은 **링크의 최대 전송률과 같은 속도로** 각각의 통신 링크에서 전송된다.
    - 출발지 종단 시스템 혹은 패킷 스위치가 `R bps(bits per second)`의 속도로 링크에서 `L 비트`의 패킷을 송신한다면,  
      그 패킷을 전송하는 데 걸리는 시간은 `L/R 초`

<br/>
<br/>

## 저장-후-전달 전송(store-and-forward transmission) 방식

> 💡 스위치가 패킷의 첫 비트를 출력 링크로 전송하기 전에 **전체 패킷**을 받아야 한다.

`저장-후-전달 전송 방식`은 대부분의 패킷 스위치가 이용하는 방식이다.

<br/>

<p align="center"><img width="500" alt="저장-후-전달 패킷 교환" src="https://user-images.githubusercontent.com/86337233/210137289-63c6e459-0892-4ee6-8a91-d35fe4f9fb51.png">

<br/>
<br/>

위는 하나의 라우터로 연결되고 2개의 종단 시스템으로 구성된 매우 간단한 네트워크 예시이다.

- 출발지는 목적지로 전송할 3개의 패킷(1, 2, 3)을 가지고 있으며, **각각의 패킷은 L 비트로 구성되어 있다.**
- 출발지는 링크에서 L 비트의 패킷을 **R bps(bits per second)의 속도로 송신**하고 있다.

<br/>

그림에서 보이는 것처럼 출발지는 `패킷 1의 일부분`을 전송했고, 그 부분이 라우터에 도착해있는 상황을 생각해보자.

이때 라우터는 저장-후-전달 방식을 채택하고 있기 때문에 수신한 비트를 전송할 수 없다. 그 대신, 아래의 과정이 진행된다.

1. 패킷의 비트를 먼저 `저장(buffer, 즉 ‘store’)`한다.
2. **라우터가 패킷의 모든 비트를 수신하였다면** 그제서야 출력 링크로 그 패킷을 `전송(transmit, 즉 ‘forward’)`하기 시작한다.

<br/>

### 경과 시간에 대한 계산

```
1-1. 출발지에서 패킷 1을 송신하기 시작해서 패킷 1의 전체를 목적지에서 수신할 때까지의 경과 시간을 계산해보자.
```

*여기서 전파 지연(propagation delay)은 무시하도록 하자. 이는 비트가 빛의 속도에 가까운 속도로 통신선을 거쳐가는 데에 걸리는 시간을 말한다.  
→ 1.4절에서 논의*

- `0 초` : 출발지가 패킷 1을 전송하기 시작
- `L/R 초`
    - 출발지는 패킷 1의 전체 데이터를 전송 완료했으며, 전체가 라우터에 수신되고 저장되었다. (전파 지연이 없기 때문)
    - **라우터가 전체 패킷을 수신했기 때문에** 라우터는 목적지를 향해 그 패킷을 출력 링크로 전송하기 시작한다.
- `2L/R 초` : 라우터는 전체 패킷을 전송했으며, 목적지는 패킷 1 전체를 수신 완료한다. (전파 지연이 없기 때문)

<br/>

따라서 저장-후-전달 전송 방식을 채택한다면 전체 지연은 `2L/R`이며,  
이 방식 없이 스위치에 비트가 도착하자마자 곧바로 전달을 하게 된다면 전체 지연은 `L/R`이 된다.

하지만 라우터는 전달하기에 앞서 전체 패킷을 수신, 저장, 처리할 필요가 있다. *(이것도 1.4절에서 자세히 논의한다.)*

<br/>

```
1-2. 출발지가 패킷 1을 송신하기 시작한 순간부터 목적지 노드가 3개의 모든 패킷(1, 2, 3)을 수신할 때까지 경과된 전체 시간을 계산해보자.
```

- `0 초` : 출발지가 패킷 1을 전송하기 시작
- `L/R 초`
    - 라우터는 패킷 1을 수신 완료, 이를 전송하기 시작
    - 출발지는 패킷 2를 전송하기 시작
- `2L/R 초`
    - 라우터는 패킷 2를 수신 완료, 이를 전송하기 시작
    - 목적지는 패킷 1 전체를 수신 완료
    - 출발지는 패킷 3을 전송하기 시작
- `3L/R 초`
    - 라우터는 패킷 3를 수신 완료, 이를 전송하기 시작
    - 목적지는 패킷 2 전체를 수신 완료
- `4L/R 초` : 목적지는 패킷 3 전체를 수신 완료

<br/>

따라서 저장-후-전달 전송 방식을 채택한다면 목적지는 `4L/R` 초에 3개의 모든 패킷을 수신하게 된다.

<br/>

### 종단 간 지연

```
2. 출발지로부터 목적지 노드까지 N개의 링크로 구성되고 각각은 전송률이 R인 경로를 통해 하나의 패킷을 전송하는 경우를 생각해보자.
```

즉, 출발지와 목적지 사이에 N-1개의 라우터가 존재한다는 것이다.

실제로 라우터는 보통 여러 개의 링크를 갖는데, 그 이유는 라우터의 기능이 **입력되는 패킷을 출력 링크로 교환**하는 것이기 때문이다.

<br/>

1-1, 1-2와 같은 논리를 적용한다면 **종단 간 지연**은 다음과 같음을 알 수 있다.

<p align="center"><img width="250" alt="종단 간 지연" src="https://user-images.githubusercontent.com/86337233/210137330-0534c802-b6cd-41e4-915d-d8a3dac5d07a.png">

<br/>
<br/>
<br/>

## 큐잉 지연(queuing delay)과 패킷 손실

* 각 패킷 스위치는 접속된 여러 `링크`를 가지고 있으며, 패킷 스위치는 **각 링크에 대해** `출력 버퍼`**를 가지고 있다.**
* 출력 버퍼(output buffer)는 출력 큐(output queue)로도 불리며, **그 링크로 송신하려고 하는 패킷을 저장하고 있다.**  
  이는 `패킷 교환`에서 중요한 역할을 한다.

패킷이 겪는 지연은 앞에서 보았던 저장-후-전달 지연만 존재하는 것이 아니다.

<br/>

```
도착하는 패킷은 한 링크로 전송되어야 한다. 하지만 만약 그 링크가 다른 패킷을 전송하고 있는 중이라면 어떻게 해야 하는가?
```

**→ 도착하는 패킷은 출력 버퍼에서 대기해야 한다.** = `큐잉 지연`

- 큐잉 지연은 가변적이며, 네트워크의 혼잡 정도에 따른다.
- 버퍼 공간의 크기는 유한하기 때문에 `패킷 손실(packet loss)`이 발생할 수 있다.
- 즉, 버퍼가 전송을 위해 대기 중인 다른 패킷들로 꽉 차 있는 경우라면 <b>도착하는 패킷 또는 큐에 대기 중인 패킷을 폐기(drop)</b>하는 것이다.

<br/>

아래의 예시를 보자.
<p align="center"><img width="500" alt="패킷 교환" src="https://user-images.githubusercontent.com/86337233/210137348-9f7c303f-5261-4e62-8885-36e36eeb4dea.png">

<br/>
<br/>

여기서 라우터는 수신한 패킷을 15 Mbps의 링크로 전달하고 있다.

만약 짧은 기간 동안 라우터에 도착하는 패킷의 전송률이 15 Mbps를 초과하게 된다면, 링크의 출력 버퍼에 패킷들이 큐잉될 것이다.

<br/>
<br/>

## 포워딩 테이블과 라우팅 프로토콜

> 라우터는 접속된 통신 링크 중 하나로 도착하는 패킷을 받아, **접속된 통신 링크 중 다른 링크로 그 패킷을 전달한다.**
>

그렇다면 라우터는 그 패킷을 어느 링크로 전달해야 하는지를 어떻게 결정할까?

_패킷 전달은 실제 여러 유형의 컴퓨터 네트워크에서 다른 방식으로 실행되는데, 여기서는 라우팅이 **인터넷**에서 어떻게 실행되는지를 간단히 설명한다._

<br/>

### IP 주소

- 인터넷에서 모든 종단 시스템은 IP 주소를 가지며, 이 주소는 계층적 구조를 갖는다.
- 출발지 종단 시스템이 목적이 종단 시스템으로 패킷을 보내고자 할 때 **출발지는 패킷의 헤더에 목적지의 IP 주소를 포함한다.**

<br/>

### 포워딩 테이블(forwarding table)

각 라우터는 **목적지 주소 또는 목적지 주소의 일부를 라우터의 출력 링크로 매핑**하는 포워딩 테이블을 가지고 있다.

따라서 라우터가 수신한 패킷을 어느 링크로 전달해야 하는지를 결정하는 과정은 다음과 같다.

1. 패킷이 라우터에 도착한다.
2. 라우터는 패킷의 IP 주소를 조사한다.
3. 해당 목적지 주소를 이용하여 포워딩 테이블을 검색한다.
4. 그 패킷을 출력 링크로 보낸다.

<br/>

### 라우팅 프로토콜(routing protocol)

그렇다면 포워딩 테이블은 어떻게 설정되는 것일까? *(5장에서 자세히 논의)*

인터넷은 **자동으로 포워딩 테이블을 설정하는 데 이용되는** 여러 특별한 라우팅 프로토콜을 가지고 있다.

e.g., 각 라우터로부터 각 목적지까지 최단 경로를 결정 → 라우터에 포워팅 테이블을 설정하는 데에는 이 최단 경로 결과를 이용한다.

<br/>
<br/>
<br/>

# 1.3.2 회선 교환(circuit switching)

- 회선 교환 네트워크에서는 종단 시스템 간에 통신을 제공하기 위해  
  <b>경로상에서 필요한 자원(버퍼, 링크 전송률)</b>은 통신 세션(session) 동안에 확보 또는 `예약(reserve)`된다. (↔︎ 패킷 교환 네트워크)
- 세션 메시지는 `온디맨드(on-demand) 방식`으로 자원을 요청하여 사용한다.
- 따라서 통신 링크에 대한 접속을 위해 **큐에서 대기해야 할 수도 있다.**

<br/>

- 연결 = `회선(circuit)` : 송신자와 수신자 간의 경로에 있는 스위치들이 해당 연결 상태를 유지해야 한다.

1. 송신자가 정보를 보내기 전, 네트워크는 송신자와 수신자 간의 **연결**을 설정해야 한다.
2. 네트워크가 회선을 설정할 때, 그 연결이 이루어지는 동안 **네트워크 링크에 일정한 전송률을 예약한다.**
3. 주어진 전송률이 송신자-수신자 연결을 위해 예약되기 때문에, **송신자는 수신자에게** `보장된(guaranteed)` **일정 전송률로 데이터를 보낼 수 있다.**

<br/>

### 종단 간 연결(end-to-end connection)

아래는 4개의 스위치와 4개의 링크로 구성된 회선 교환 네트워크를 나타낸 그림이다.

이들 각 링크는 4개의 회선을 가지므로 **각 링크는 4개의 동시 연결을 지원할 수 있다.**

<p align="center"><img width="470" alt="회선 교환 네트워크" src="https://user-images.githubusercontent.com/86337233/210137402-59bd4469-e343-430c-96df-9f5c6c072005.png">

<br/>
<br/>


만약 두 호스트가 통신하고 싶을 때, 네트워크는 두 호스트 사이에 지정된 `종단 간 연결`을 설정한다.

즉, 호스트 A가 호스트 B와 통신하기 위해서 네트워크는 먼저 **A의 링크와 B의 링크 각각에서 한 회선씩을 예약**한다.  
(위 그림에서는 링크(0, 0)의 두 번째 회선, 링크(1, 1)의 두 번째 회선)

각 링크에 대하여 연결이 지속되는 동안 해당 연결은 링크 전체 전송 용량의 1/4를 얻는다. (각 링크는 4개의 회선을 가지고 있기 때문)

<br/>

---

<br/>

```
반대로, 한 호스트가 인터넷 같은 패킷 교환 네트워크를 통해 다른 호스트로 패킷을 보내고자 하는 경우에는 어떤 일이 발생할까?
```

회선 교환과 마찬가지로 패킷은 일련의 통신 링크를 통해 전송된다.

하지만 회선 교환과는 다르게, **패킷 교환은 링크 자원을 예약하지 않고 네트워크로 보내진다.**

<br/>

> 💡 패킷 교환 네트워크는 일정한 시간 내에 데이터를 전달하는 것을 보장하지 않는다.

<br/>
<br/>

## 회선 교환 네트워크에서의 다중화

링크 내 한 회선이 구현되는 방법

1. `주파수 분할 다중화(Frequency-Division Multiplexing, FDM)` : 각 회선은 **지속적으로** 대역폭의 **일부**를 얻는다.
2. `시분할 다중화(Time-Division Multiplexing, TDM)` : 각 회선은 <b>주기적으로</b>(짧은 시간 즉, 슬롯 동안) **전체** 대역폭을 얻는다.

<br/>

### 주파수 분할 다중화(Frequency-Division Multiplexing, FDM)

- 링크를 통해 설정된 연결은 그 링크의 주파수 스펙트럼을 공유한다.
- 그 링크는 연결되는 동안 각 연결에 대해 **주파수 대역을 고정 제공**한다. = `대역폭(bandwidth)`

<p align="center"><img width="300" alt="FDM" src="https://user-images.githubusercontent.com/86337233/210137431-63860cea-2921-47f8-89f4-19656ee81de5.png">

<br/>
<br/>

### 시분할 다중화(Time-Division Multiplexing, TDM)

- TDM 링크는 **시간을 일정 주기의 프레임으로 구분**하고, 각 프레임은 고정된 수의 `시간 슬롯`으로 나뉜다.
- 네트워크가 링크를 통해 하나의 연결을 설정할 때, 네트워크는 모든 프레임에서 **시간 슬롯 1개를 그 연결에 할당**한다.
- 전송률 : 한 슬롯 안의 비트 수 × 프레임 전송률

<p align="center"><img width="350" alt="TDM" src="https://user-images.githubusercontent.com/86337233/210137432-426fd263-6cac-45ab-8262-a82bf772e1cc.png">

<br/>
<br/>

### 패킷 교환 대 회선 교환

**[ 패킷 교환 옹호자 ]**

- 주장
    1. 패킷 교환이 회선 교환보다 전송 용량의 공유에서 더 효율적이다.
    2. 패킷 교환이 회선 교환보다 더 간단하고 효율적이며, 구현 비용이 적다.
- 근거
    - 회선 교환에서 통신을 위해서는 자원이 항상 **각각의** 사용자에게 **예약**되어야만 한다.
    - 할당된 회선이 `비활용 기간(silent period)`에는 자원을 점유한 채로 놀게 되기 때문에 자원 이용률이 감소한다.
    - 즉, 회선 교환에서는 사용되지 않는 네트워크 자원(연결 경로상의 링크 주파수 대역이나 슬롯)은 **다른 진행 중인 연결이 대신해서 사용할 수 없기 때문에**  
      패킷 교환이 더 효율적이다.

<br/>

**[ 패킷 교환 반대자 ]**

- 주장 : 패킷 교환은 실시간 서비스에는 적당하지 않다.
- 근거 : 주로 큐잉 지연에서 발생하는 **종단 간의 지연** (불규칙적이고 예측할 수 없음)

<br/>

과연 패킷 교환 반대자의 주장은 옳을까?

이를 확인해보기 위해서 간단한 예 두 가지를 살펴보자.

<br/>

---

<br/>

```
1. 사용자가 1 Mbps 링크를 공유한다고 가정하고, 각 사용자들은 활동 시간과 비활동 시간을 반복한다고 하자.
사용자는 전체 시간에서 10%만 활동하며 나머지 90% 시간에는 활동하지 않는다.
```

- 활동 시간 : 100 kbps의 일정 속도로 데이터를 생산할 때
- 비활동 시간 : 데이터를 생산하지 않을 때

<br/>

✅ `회선 교환`의 경우, 100 kbps가 항상 각각의 사용자에게 예약되어야 한다.  
TDM 회선 교환을 예시로, 초 프레임이 100 ms마다 10개 시간 슬롯으로 나뉜다고 한다면 각 사용자에게는 **한 프레임에 한 번의 시간 슬롯**이 할당된다.  
따라서 회선 교환 링크는 **동시에 10명(= 1 Mbps / 100 kbps)만 지원할 수 있다.**

<br/>

✅ `패킷 교환`의 경우, 한 특정 사용자가 활동을 하고 있을 확률은 10%이다.  
만약 10명 이하의 동시 사용자가 있다면 그 확률은 99.96%, 데이터의 통합 도착률은 1 Mbps(링크의 출력률)보다 작거나 같다.  
따라서 **10명 이상의 동시 사용자가 있다면 패킷의 통합 도착률이 링크의 출력 용량을 초과하기 때문에 출력 큐가 커지기 시작한다.**  
(이 큐는 통합 입력률이 1 Mbps 이하로 떨어질 때까지 커질 것이고, 이후에는 큐 길이가 줄어들기 시작할 것)

<br/>

10명 이상의 동시 사용자가 있을 확률은 0.04%로 굉장히 작으므로,  
**패킷 교환은 거의 항상 회선 교환과 대등한 지연 성능을 가지면서도** 거의 3배 이상의 사용자 수를 허용한다.

<br/>

---

<br/>

```
2. 10명의 사용자가 있다고 가정하자. 1번과 동일하게, 사용자는 1 Mbps 링크를 공유한다.
한 사용자가 한번에 1,000비트 패킷을 1,000개 생성하고 다른 사용자는 패킷을 생성하지 않는다.
```

<br/>

✅ `회선 교환`의 경우를 먼저 보자.  
TDM 회선 교환을 예시로, 한 프레임은 10개 슬롯으로 구성되고 각 슬롯은 1,000비트로 구성되었다면  
사용자는 데이터 전송을 위해 **한 프레임당 1개의 시간 슬롯만 사용할 수 있다.** 반면에 각 프레임에 남겨진 9개의 시간 슬롯은 쉬는 상태가 된다.  
따라서 사용자의 데이터 **100만 비트를 모두 전송하려면 10초가 걸린다.**

<br/>

✅ `패킷 교환`의 경우,  
패킷을 생성하는 다른 사용자가 없기 때문에 다중화가 요구되지 않고, 사용자는 1 Mbps의 링크가 가득 찰 때까지 패킷을 계속 보낼 수 있다.  
따라서 사용자의 데이터 100만 비트는 **1초 만에 모두 전송된다.**


<br/>

---

<br/>

앞의 두 가지 예에서 명확하게 볼 수 있듯, **패킷 교환이 회선 교환보다 성능이 우수하다.**

따라서 오늘날의 전기통신 네트워크의 추세는 패킷 교환으로 전환되고 있다.

<br/>

링크 전송률을 공유하는 두 방식의 가장 큰 차이점은 아래와 같이 정리할 수 있다.

- 회선 교환 방식 : 요구에 관계없이 미리 전송 링크의 사용을 할당한다.
- 패킷 교환 방식 : **요구할 때만** 링크의 사용을 할당한다.

<br/>
<br/>
<br/>

# 1.3.3 네트워크의 네트워크

### 접속 ISP

- `ISP(Internet Service Provider)` : 패킷 스위치와 통신 링크로 이루어진 네트워크
    1. 종단 시스템에게 다양한 네트워크 접속을 제공한다. (e.g., 가정용 초고속 접속, 고속 LAN 접속, 이동 무선 접속 등)
    2. CP(content provider)에게 인터넷 접속을 제공 → 웹 사이트나 비디오 서버를 인터넷에 직접 연결할 수 있게 된다.


- 종단 시스템(PC, 스마트폰, 웹 서버 등)은 **접속 ISP를 통해 인터넷에 연결된다.**
- 접속 ISP는 다양한 접속 기술(DSL, 케이블, FTTH, 와이파이, 셀룰러(이동 통신) 등)을 이용하여 유선 또는 무선 연결을 제공한다.

<br/>

접속 ISP는 텔코 혹은 케이블 회사일 필요가 없다.  
e.g., 대학교 - 학생, 직원, 교수에게 인터넷 접속을 제공, 회사 - 직원에게 인터넷 접속을 제공

그러나 종단 사용자들과 콘텐츠 제공자들을 모두 접속 ISP로 연결하는 것은 말도 안 된다.

이를 위해서는 **접속 ISP들이 서로 연결되어야만 하기 때문에** `네트워크의 네트워크(network of network)`가 탄생하게 되었다.

<br/>

> 💡 목표 : **모든 종단 시스템이 서로에게 패킷을 보낼 수 있도록** 접속 ISP를 연결하는 것

가장 간단한 방법은 각 접속 ISP를 직접 서로 다른 ISP와 연결하는 것이다.

하지만 각 접속 ISP가 전 세계적으로 다른 접속 ISP와 수십만 개의 개별적인 통신 링크를 유지해야 하기 때문에,  
이런 그물망 설계는 접속 ISP에게 너무 많은 비용을 발생시킨다.

<br/>

오늘날의 인터넷 네트워크 구조를 이해하기 위해 점진적으로 일련의 네트워크 구조를 만들어보자.

<br/>

## 네트워크 구조 1

> 모든 접속 ISP를 **하나의 글로벌 통과(transit) ISP**와 연결한다.

- `글로벌 통과 ISP` : 라우터 + 전 세계에 이르고, 적어도 수십만 개의 접속 ISP와 가까운 곳에 있는 라우터를 갖는 통신 링크의 네트워크
- 글로벌 ISP가 이러한 확장된 네트워크를 구축하는 데는 매우 많은 비용이 든다.
- 글로벌 ISP는 이익을 얻기 위해 **각각의 접속 ISP에 연결을 위한 과금**을 부과한다.
    - 접속 ISP는 `고객(customer)`
    - 글로벌 ISP는 `제공자(provider)`

<br/>
<br/>

## 네트워크 구조 2

어느 회사가 수익을 내는 글로벌 ISP를 구축하고 운영한다면, 다른 회사가 자신의 글로벌 ISP를 구축하여 경쟁하는 것은 자연스러운 일이다.

이것이 네트워크 구조 2로 진화한다.

<br/>

> 수십만 개의 접속 ISP와 **다중의 글로벌 ISP**

- `2계층구조`
    - 상위층 : 글로벌 ISP 서비스 제공자가 존재
    - 하위층 : 접속 ISP가 존재
- **글로벌 ISP들은 서로 연결해야만 한다.**
- 서로 연결되지 않는다면 하나의 글로벌 ISP와 연결된 접속 ISP는 다른 글로벌 통과 서비스 제공자에 연결된 접속 ISP와 통신할 수 없다.

<br/>

### 지역 ISP와 1계층 ISP

현실적으로 전 세계의 모든 도시에 존재하는 ISP는 없다.

대신, 어느 주어진 지역에서 그 지역에 있는 접속 ISP들이 연결하는 `지역(regional) ISP`가 존재하며, 각 지역 ISP는 `1계층(tier-1) ISP`들과 연결된다.  
*(실제로 존재하는 1계층 ISP는 전 세계적으로 모든 도시에 존재하지는 않는다.)*

<br/>
<br/>

## 네트워크 구조 3

> **다중계층구조(접속 ISP, 지역 ISP, 1계층 ISP)** *→ 오늘날의 인터넷과 대략적으로 유사*

여러 경쟁적인 1계층 ISP들이 존재하며, 한 지역에 여러 경쟁적인 지역 ISP들이 존재할 수 있다.

더 복잡한 경우, 작은 지역 ISP들이 연결하는 좀 더 큰 지역 ISP들이 있을 수 있다.

<br/>

이런 계층구조에서의 과금은 크게 다음과 같이 진행된다.

고객 ISP는 글로벌 인터넷 연결성(interconnectivity)을 얻기 위해 서비스 제공 ISP에게 요금을 지불하기 때문에  
"각 레벨에는 고객-제공자 관계가 존재한다"고 할 수 있다.

1. 각각의 **접속 ISP**는 자신이 연결하는 **지역 ISP에게** 요금을 지불한다.
2. 각 **지역 ISP**는 자신이 연결하는 **1계층 ISP에게** 요금을 지불한다.
3. 1계층 ISP는 계층구조의 최상위에 있기 때문에 아무에게도 요금을 지불하지 않는다.

<br/>
<br/>

## 네트워크 구조 4

> 다중계층구조(접속 ISP, 지역 ISP, 1계층 ISP) + **PoP + 멀티홈 + 피어링 + IXP**

<br/>

오늘날의 인터넷과 좀 더 유사한 네트워크를 구축하기 위해서는 네트워크 구조 3에 아래 4가지 항목들을 포함해야 한다.

- `PoP(Points of Presence)`
    - 단지 제공자의 네트워크 내에 있는(같은 위치에 존재하는) 하나 혹은 그 이상의 라우터 그룹
    - 최하위(접속 ISP) 계층을 제외한 모든 계층에 존재하며, **고객 ISP가 제공자 ISP에 연결될 수 있다.**
    - 고객 네트워크가 제공자의 PoP에 연결되기 위해,  
      고객은 자신의 라우터 중 하나를 PoP에 있는 라우터에 직접 연결하도록 **고속 링크를 제3자(third-party) 통신 서비스 제공자로부터 임대할 수 있다.**


- `멀티홈(multi-homing)`
    - **둘 혹은 그 이상의 제공자 ISP에 연결하는 것**
    - e.g., 한 접속 ISP가 2개의 ISP에 연결, 2개의 지역 ISP와 함께 하나의 1계층 ISP에 연결
    - 1계층 ISP를 제외한 모든 ISP는 멀티홈을 선택할 수 있다.
    - 한 ISP가 멀티홈을 하면 서비스 제공자 중 하나가 연결되지 않더라도 인터넷으로 패킷을 계속 송수신할 수 있게 된다.


- `피어링(peering)`
    - 고객 ISP가 서비스 제공 ISP에게 지불하는 요금을 줄이기 위해 **인터넷 계층구조의 같은 계층에 있는 가까운 ISP들은 피어링할 수 있다.**  
      (두 ISP가 피어링하면 일반적으로 서로 요금을 지불하지 않음)
    - 즉, 이들 간에 송수신되는 모든 트래픽을 **상위 계층 ISP를 통하지 않고 직접 송수신할 수 있도록** 자신들의 네트워크를 서로 직접 연결하는 것이다.
    - 1계층 ISP들도 서로 피어링할 수 있다.


- `IXP(Internet Exchange Point)`
    - 다중의 ISP들이 서로 피어링할 수 있는 만남의 장소
    - 일반적으로 교환기를 갖춘 독자적인 빌딩에 존재한다.

<br/>
<br/>

## 네트워크 구조 5

> 다중계층구조(접속 ISP, 지역 ISP, 1계층 ISP) + PoP + 멀티홈 + 피어링 + IXP + **콘텐츠 제공 네트워크**

<br/>

이는 2012년의 인터넷을 기술하며, **구글**이 이러한 콘텐츠 제공자 네트워크 주도하는 한 예이다.

- 구글 데이터 센터는 모두 구글의 사설 TCP/IP 네트워크를 통해 연결되어 있으며, 이 네트워크는 전 세계를 연결하며 공중 인터넷과는 분리되어 있다.
- **구글 사설 네트워크는 구글 서버로 오가는 트래픽만 전달한다.**
- 즉, 하위 계층 ISP들과 피어링을 함으로써(그들과 직접 연결하거나 IXP에서 그들과 연결함으로써) 인터넷의 상위 계층을 ‘`우회(bypass)`’하고 있다.  
  (아래 그림 참고)

<br/>

- 많은 접속 ISP는 여전히 1계층 네트워크를 통해서만 도달할 수 있기 때문에  
  구글 네트워크도 1계층 ISP들과 연결하고 그들과 교환하는 트래픽에 대해 이 ISP들에게 요금을 지불한다.
- 콘텐츠 제공자들이 자신의 네트워크를 구축함으로써 얻는 이점
    - 상위 계층 ISP들에게 지불하는 요금을 줄일 수 있다.
    - 최종 사용자들에게 자신들의 서비스가 궁극적으로 어떻게 전달되는지에 대한 더 많은 통제권을 가질 수 있다.

<br/>

<p align="center"><img width="580" alt="ISP의 연결" src="https://user-images.githubusercontent.com/86337233/210137433-fd5cf02e-5e56-4acc-94c1-d3bdb4697b13.png">

<br/>
<br/>

---

<br/>

최종 정리하자면 다음과 같다.

> 💡 오늘날의 <b>인터넷(네트워크의 네트워크)</b>는 12개 정도의 1계층 ISP들과 수십만 개의 하위 계층 ISP들로 구성되어 있다.

- 하위 계층 ISP들은 상위 계층 ISP들과 연결하고, 상위 계층 ISP들은 서로 연결한다.
- 사용자와 콘텐츠 제공자는 하위 계층 ISP 고객이고, 하위 계층 ISP들은 상위 계층 ISP들이 고객이다.
- 최근에 주요 콘텐츠 제공자도 자신의 네트워크를 구축했고 가능한 곳에서 하위 계층 ISP들과 직접 연결한다.
