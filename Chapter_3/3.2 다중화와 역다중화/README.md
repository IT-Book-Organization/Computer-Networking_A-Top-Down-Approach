# 3.2 다중화와 역다중화

> 💡 **트랜스포트 계층 다중화(multiplexing)와 역다중화(demultiplexing)**  
> 네트워크 계층이 제공하는 `호스트 대 호스트 전달 서비스`에서  
> 호스트에서 동작하는 애플리케이션에 대한 `프로세스 대 프로세스 전달 서비스`로 확장하는 과정

<br/>

1. 목적지 호스트에서의 트랜스포트 계층은 바로 아래의 네트워크 계층으로부터 `세그먼트`를 수신한다.
   > 트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 **이 세그먼트의 데이터를 전달하는 의무**를 가진다.

<br/>

2. 트랜스포트 계층은 세그먼트(데이터)를 중간 매개자인 `소켓(socket)`에게 전달한다.
    - 프로세스는 네트워크 애플리케이션의 한 부분으로서 소켓을 가지고 있다.
    - 이는 네트워크에서 프로세스로, 한 프로세스로부터 네트워크로 **데이터를 전달하는 출입구 역할**을 한다.
    - 각각의 소켓은 하나의 유일한 식별자, `포트 번호(port number)`를 가진다.

<br/>

<p align="center"><img width="700" alt="다중화와 역다중화" src="https://user-images.githubusercontent.com/86337233/211320111-82e0f6d5-f5f7-436c-8d5c-a3be0b178547.png">

<br/>
<br/>

---

<br/>

```
Q. 수신한 트랜스포트 계층 세그먼트는 어떻게 적절한 소켓으로 향하는가?
```

각각의 트랜스포트 계층 세그먼트는 세그먼트에 **필드 집합**을 가지고 있으며,  
트랜스포트 계층은 수신 소켓을 식별하기 위해 이러한 필드를 검사한 후 해당 소켓으로 보낸다.

<br/>

### ✅ 역다중화(demultiplexing)

트랜스포트 계층 세그먼트의 데이터를 **올바른 소켓으로 전달하는** 작업을 말한다.

<br/>

### ✅ 다중화(multiplexing)

1. 출발지 호스트에서 소켓으로 부터 데이터를 모으고,
2. 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화(encapsulation) 한다.
3. 그 세그먼트들을 **네트워크 계층으로 전달한다.**

<br/>

### 트랜스포트 계층 다중화의 두 가지 요구사항

1. 소켓은 **유일한 식별자**를 갖는다. (= 포트 번호)
2. 각 세그먼트는 세그먼트가 **전달될 적절한 소켓을 가리키는 특별한 필드**를 갖는다.
    - `출발지 포트 번호 필드(source port number field)`
    - `목적지 포트 번호 필드(destination port number field)`

    <br/>
    <p align="center"><img width="270" alt="필드" src="https://user-images.githubusercontent.com/86337233/211320125-ff37b76f-2ad8-43d8-9b1a-56872c592a5c.png">

<br/>

### 역다중화 서비스의 순서

1. 호스트의 각 소켓은 포트 번호를 할당받는다.
2. 세그먼트가 호스트에 도착하면,
    1. 트랜스포트 계층은 세그먼트 안의 **목적지 포트 번호를 검사**하고,
    2. 그에 상응하는 소켓으로 세그먼트를 보낸다.
3. 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다.

이는 UDP의 기본적인 동작 방식과 같다.

<br/>
<br/>

## 비연결형 다중화와 역다중화

> 💡 UDP 소켓은 `목적지 IP 주소`와 `목적지 포트 번호`로 구성된 두 요소로 된 집합에 의해 식별된다.

따라서 만약 2개의 UDP 세그먼트가 **같은 목적지 IP 주소와 목적지 포트 번호**를 가진다면,  
이 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향할 것이다.

<br/>

그렇다면 **출발지 포트 번호**는 무슨 목적으로 사용되는가?

> `출발지 포트 번호`는 <b>‘회신 주소’</b>의 한 부분으로 사용된다.

<br/>

아래 그림처럼, B가 A에게로 세그먼트를 보내기를 원할 때  
B에서 A로 가는 **세그먼트의 목적지 포트 번호는** A로부터 B로 가는 세그먼트의 **출발지 포트 번호로부터 가져온다.**

<br/>

<p align="center"><img width="650" alt="출발지와 목적지 포트 번호의 전환" src="https://user-images.githubusercontent.com/86337233/211320120-b319557b-49d0-47d8-a7f5-671cb51131d8.png">

<br/>
<br/>

## 연결지향형 다중화와 역다중화

### TCP 소켓

> 💡 TCP 소켓은 `4개 요소의 집합(four-tuple)`에 의해 식별된다.

- 출발지 IP 주소
- 출발지 포트 번호
- 목적지 IP 주소
- 목적지 포트 번호

<br/>

특히, **다른 출발지 IP 주소 또는 다른 출발지 포트 번호**를 가지고 도착하는 2개의 TCP 세그먼트는 2개의 다른 소켓으로 향하게 된다.  
_(초기 연결 설정 요청을 전달하는 TCP는 제외)_

<br/>

### TCP 연결 설정

1. TCP 서버 애플리케이션은 `환영(welcome) 소켓`을 갖고 있다.  
   이 소켓은 `포트 번호 12000`을 가진 **TCP 클라이언트로부터 연결 설정 요청을 기다린다.** _(아래 그림 참고)_

    <br/>
    <p align="center"><img width="500" alt="TCP" src="https://user-images.githubusercontent.com/86337233/211320130-8033e75c-8713-4db2-9ecb-be5768fab8a8.png">
    <br/><br/>


2. TCP 클라이언트는 **소켓을 생성하고,** `연결 설정 요청 세그먼트`**를 보낸다.**
    - 연결 설정 요청은 `목적지 포트 번호 12000`과 TCP 헤더에 설정된 특별한 연결 설정 비트(3.5절에서 설명)를 가진 TCP 세그먼트를 통해 보내진다.
    - 이 세그먼트는 `출발지 포트 번호`를 포함하는데, 이것은 클라이언트가 선택한 번호이다.


3. 서버 프로세스로 동작하는 컴퓨터의 호스트 운영체제가 `목적지 포트 12000`을 포함하는 연결 요청 세그먼트를 수신하면,  
   이 세그먼트를 **포트 번호 12000으로 연결 수락을 기다리는 서버 프로세스로 보낸다.**


4. 서버는 연결 요청 세그먼트의 4개 요소의 집합에 주목한다.
   > 서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다.
    - **새롭게 생성된 연결 소켓은 4개 요소의 집합의 네 가지 값에 의해 식별된다.**
    - 따라서 그다음에 도착하는 세그먼트의 출발지 포트, 출발지 IP 주소, 목적지 포트, 목적지 IP 주소가 **전부 일치하면,**  
      그 세그먼트는 이 소켓으로 역다중화될 것이다.

<br/>
<br/>

## 웹 서버와 TCP

> 💡 서버는 각기 다른 클라이언트가 보낸 세그먼트를 `출발지 IP 주소`와 `출발지 포트 번호`로 구별한다.

<br/>

같은 웹 서버 애플리케이션과 통신하기 위해 **같은 목적지 포트 번호(80)를 이용하는 두 클라이언트**에 대한 예시를 보자.

- **호스트 C가 서버 B로** 2개의 HTTP 세션을 시작
- **호스트 A가 서버 B로** 하나의 HTTP 세션을 시작

<br/>

<p align="center"><img width="700" alt="웹 서버 애플리케이션 통신" src="https://user-images.githubusercontent.com/86337233/211320137-5c90b955-b4b2-4dcb-ab04-8f25e6b24d2e.png">

<br/>
<br/>

호스트 A, 호스트 C, 서버 B는 **각자 유일한 IP 주소인 A, C, B를 각각 가지고 있다.**

- 호스트 C는 2개의 출발지 포트 번호(26145, 7532)를 자신의 HTTP 연결에 할당한다.
- 호스트 A는 호스트 C와 독립적으로 출발지 포트 번호를 선택하므로,
  **이것 또한 HTTP 연결에 출발지 포트로 26145를 할당할 수 있다.**

<br/>

> 이렇게 하더라도, **2개의 연결은 다른 출발지 IP 주소를 가지기 때문에** 서버 B는 여전히 올바르게 역다중화할 수 있다.

<br/>

---

<br/>

웹 서버는 각각의 연결에 따라서 새로운 `프로세스`를 만든다.

이들 **프로세스는 각자** `연결 소켓`**을 가지며**, 이 연결 소켓을 통해 HTTP 요청을 수신하고, HTTP 응답을 전송한다.

<br/>

> 그러나 연결 소켓과 프로세스 사이에 항상 일대일 대응이 이루어지는 것이 아니다.

- 오늘날의 많은 고성능 웹 서버는 하나의 프로세스만 사용한다.
- 각각의 새로운 클라이언트 연결을 위해 새로운 연결 소켓과 함께 새로운 `스레드(thread)`를 생성한다.

<br/>
<br/>

## Persistent & Non-persistent HTTP

### 지속적인(persistent) HTTP

지속적인 연결의 존속 기간에 클라이언트와 서버는 **같은 서버 소켓을 통해** HTTP 메시지를 교환한다.

<br/>

### 비지속적인(non-persistent) HTTP

모든 요청/응답마다 새로운 TCP 연결이 생성되고 종료된다.
